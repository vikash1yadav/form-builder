{"ast":null,"code":"/*\n * Original author: Joder Illi\n * Integration in Natural by Hugo W.L. ter Doest\n *\n * Copyright (c) 2010, FormBlitz AG\n * All rights reserved.\n * Implementation of the stemming algorithm from http://snowball.tartarus.org/algorithms/german/stemmer.html\n * Copyright of the algorithm is: Copyright (c) 2001, Dr Martin Porter and can be found at http://snowball.tartarus.org/license.php\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, is covered by the standard BSD license.\n *\n*/\n\n'use strict';\n\nconst Stemmer = require('./stemmer_de');\nconst PorterStemmer = new Stemmer();\nPorterStemmer.stem = stemm;\nmodule.exports = PorterStemmer;\n\n/* by Joder Illi, Snowball mailing list */\nfunction stemm(word) {\n  /*\n  Put u and y between vowels into upper case\n  */\n  word = word.replace(/([aeiouyäöü])u([aeiouyäöü])/g, '$1U$2');\n  word = word.replace(/([aeiouyäöü])y([aeiouyäöü])/g, '$1Y$2');\n\n  /*\n  and then do the following mappings,\n  (a) replace ß with ss,\n  (a) replace ae with ä, Not doing these,\n  have trouble with diphtongs\n  (a) replace oe with ö, Not doing these,\n  have trouble with diphtongs\n  (a) replace ue with ü unless preceded by q. Not doing these,\n  have trouble with diphtongs\n  So in quelle, ue is not mapped to ü because it follows q, and in\n  feuer it is not mapped because the first part of the rule changes it to\n  feUer, so the u is not found.\n  */\n  word = word.replace(/ß/g, 'ss');\n  // word = word.replace(/ae/g, 'ä');\n  // word = word.replace(/oe/g, 'ö');\n  // word = word.replace(/([^q])ue/g, '$1ü');\n\n  /*\n  R1 and R2 are first set up in the standard way (see the note on R1\n  and R2), but then R1 is adjusted so that the region before it contains at\n  least 3 letters.\n  R1 is the region after the first non-vowel following a vowel, or is\n  the null region at the end of the word if there is no such non-vowel.\n  R2 is the region after the first non-vowel following a vowel in R1,\n  or is the null region at the end of the word if there is no such non-vowel.\n  */\n\n  let r1Index = word.search(/[aeiouyäöü][^aeiouyäöü]/);\n  let r1 = '';\n  if (r1Index !== -1) {\n    r1Index += 2;\n    r1 = word.substring(r1Index);\n  }\n  let r2Index = -1;\n  // let r2 = ''\n\n  if (r1Index !== -1) {\n    r2Index = r1.search(/[aeiouyäöü][^aeiouyäöü]/);\n    if (r2Index !== -1) {\n      r2Index += 2;\n      // r2 = r1.substring(r2Index)\n      r2Index += r1Index;\n    } else {\n      // r2 = ''\n    }\n  }\n  if (r1Index !== -1 && r1Index < 3) {\n    r1Index = 3;\n    r1 = word.substring(r1Index);\n  }\n\n  /*\n  Define a valid s-ending as one of b, d, f, g, h, k, l, m, n, r or t.\n  Define a valid st-ending as the same list, excluding letter r.\n  */\n\n  /*\n  Do each of steps 1, 2 and 3.\n  */\n\n  /*\n  Step 1:\n  Search for the longest among the following suffixes,\n  (a) em ern er\n  (b) e en es\n  (c) s (preceded by a valid s-ending)\n  */\n  const a1Index = word.search(/(em|ern|er)$/g);\n  const b1Index = word.search(/(e|en|es)$/g);\n  let c1Index = word.search(/([bdfghklmnrt]s)$/g);\n  if (c1Index !== -1) {\n    c1Index++;\n  }\n  let index1 = 10000;\n  let optionUsed1 = '';\n  if (a1Index !== -1 && a1Index < index1) {\n    optionUsed1 = 'a';\n    index1 = a1Index;\n  }\n  if (b1Index !== -1 && b1Index < index1) {\n    optionUsed1 = 'b';\n    index1 = b1Index;\n  }\n  if (c1Index !== -1 && c1Index < index1) {\n    optionUsed1 = 'c';\n    index1 = c1Index;\n  }\n\n  /*\n  and delete if in R1. (Of course the letter of the valid s-ending is\n  not necessarily in R1.) If an ending of group (b) is deleted, and the ending\n  is preceded by niss, delete the final s.\n  (For example, äckern -> äck, ackers -> acker, armes -> arm,\n  bedürfnissen -> bedürfnis)\n  */\n\n  if (index1 !== 10000 && r1Index !== -1) {\n    if (index1 >= r1Index) {\n      word = word.substring(0, index1);\n      if (optionUsed1 === 'b') {\n        if (word.search(/niss$/) !== -1) {\n          word = word.substring(0, word.length - 1);\n        }\n      }\n    }\n  }\n\n  /*\n  Step 2:\n  Search for the longest among the following suffixes,\n  (a) en er est\n  (b) st (preceded by a valid st-ending, itself preceded by at least 3\n  letters)\n  */\n\n  const a2Index = word.search(/(en|er|est)$/g);\n  let b2Index = word.search(/(.{3}[bdfghklmnt]st)$/g);\n  if (b2Index !== -1) {\n    b2Index += 4;\n  }\n  let index2 = 10000;\n  // const optionUsed2 = ''\n  if (a2Index !== -1 && a2Index < index2) {\n    // optionUsed2 = 'a'\n    index2 = a2Index;\n  }\n  if (b2Index !== -1 && b2Index < index2) {\n    // optionUsed2 = 'b'\n    index2 = b2Index;\n  }\n\n  /*\n  and delete if in R1.\n  (For example, derbsten -> derbst by step 1, and derbst -> derb by\n  step 2, since b is a valid st-ending, and is preceded by just 3 letters)\n  */\n\n  if (index2 !== 10000 && r1Index !== -1) {\n    if (index2 >= r1Index) {\n      word = word.substring(0, index2);\n    }\n  }\n\n  /*\n  Step 3: d-suffixes (*)\n  Search for the longest among the following suffixes, and perform the\n  action indicated.\n  end ung\n  delete if in R2\n  if preceded by ig, delete if in R2 and not preceded by e\n  ig ik isch\n  delete if in R2 and not preceded by e\n  lich heit\n  delete if in R2\n  if preceded by er or en, delete if in R1\n  keit\n  delete if in R2\n  if preceded by lich or ig, delete if in R2\n  */\n\n  const a3Index = word.search(/(end|ung)$/g);\n  let b3Index = word.search(/[^e](ig|ik|isch)$/g);\n  const c3Index = word.search(/(lich|heit)$/g);\n  const d3Index = word.search(/(keit)$/g);\n  if (b3Index !== -1) {\n    b3Index++;\n  }\n  let index3 = 10000;\n  let optionUsed3 = '';\n  if (a3Index !== -1 && a3Index < index3) {\n    optionUsed3 = 'a';\n    index3 = a3Index;\n  }\n  if (b3Index !== -1 && b3Index < index3) {\n    optionUsed3 = 'b';\n    index3 = b3Index;\n  }\n  if (c3Index !== -1 && c3Index < index3) {\n    optionUsed3 = 'c';\n    index3 = c3Index;\n  }\n  if (d3Index !== -1 && d3Index < index3) {\n    optionUsed3 = 'd';\n    index3 = d3Index;\n  }\n  if (index3 !== 10000 && r2Index !== -1) {\n    if (index3 >= r2Index) {\n      word = word.substring(0, index3);\n      let optionIndex = -1;\n      // const optionSubsrt = ''\n      if (optionUsed3 === 'a') {\n        optionIndex = word.search(/[^e](ig)$/);\n        if (optionIndex !== -1) {\n          optionIndex++;\n          if (optionIndex >= r2Index) {\n            word = word.substring(0, optionIndex);\n          }\n        }\n      } else if (optionUsed3 === 'c') {\n        optionIndex = word.search(/(er|en)$/);\n        if (optionIndex !== -1) {\n          if (optionIndex >= r1Index) {\n            word = word.substring(0, optionIndex);\n          }\n        }\n      } else if (optionUsed3 === 'd') {\n        optionIndex = word.search(/(lich|ig)$/);\n        if (optionIndex !== -1) {\n          if (optionIndex >= r2Index) {\n            word = word.substring(0, optionIndex);\n          }\n        }\n      }\n    }\n  }\n\n  /*\n  Finally,\n  turn U and Y back into lower case, and remove the umlaut accent from\n  a, o and u.\n  */\n  word = word.replace(/U/g, 'u');\n  word = word.replace(/Y/g, 'y');\n  word = word.replace(/ä/g, 'a');\n  word = word.replace(/ö/g, 'o');\n  word = word.replace(/ü/g, 'u');\n  return word;\n}","map":{"version":3,"names":["Stemmer","require","PorterStemmer","stem","stemm","module","exports","word","replace","r1Index","search","r1","substring","r2Index","a1Index","b1Index","c1Index","index1","optionUsed1","length","a2Index","b2Index","index2","a3Index","b3Index","c3Index","d3Index","index3","optionUsed3","optionIndex"],"sources":["C:/Users/shail/OneDrive/Documents/GitHub/form-builder/form-builder/node_modules/natural/lib/natural/stemmers/porter_stemmer_de.js"],"sourcesContent":["/*\n * Original author: Joder Illi\n * Integration in Natural by Hugo W.L. ter Doest\n *\n * Copyright (c) 2010, FormBlitz AG\n * All rights reserved.\n * Implementation of the stemming algorithm from http://snowball.tartarus.org/algorithms/german/stemmer.html\n * Copyright of the algorithm is: Copyright (c) 2001, Dr Martin Porter and can be found at http://snowball.tartarus.org/license.php\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, is covered by the standard BSD license.\n *\n*/\n\n'use strict'\n\nconst Stemmer = require('./stemmer_de')\n\nconst PorterStemmer = new Stemmer()\nPorterStemmer.stem = stemm\nmodule.exports = PorterStemmer\n\n/* by Joder Illi, Snowball mailing list */\nfunction stemm (word) {\n  /*\n  Put u and y between vowels into upper case\n  */\n  word = word.replace(/([aeiouyäöü])u([aeiouyäöü])/g, '$1U$2')\n  word = word.replace(/([aeiouyäöü])y([aeiouyäöü])/g, '$1Y$2')\n\n  /*\n  and then do the following mappings,\n  (a) replace ß with ss,\n  (a) replace ae with ä, Not doing these,\n  have trouble with diphtongs\n  (a) replace oe with ö, Not doing these,\n  have trouble with diphtongs\n  (a) replace ue with ü unless preceded by q. Not doing these,\n  have trouble with diphtongs\n  So in quelle, ue is not mapped to ü because it follows q, and in\n  feuer it is not mapped because the first part of the rule changes it to\n  feUer, so the u is not found.\n  */\n  word = word.replace(/ß/g, 'ss')\n  // word = word.replace(/ae/g, 'ä');\n  // word = word.replace(/oe/g, 'ö');\n  // word = word.replace(/([^q])ue/g, '$1ü');\n\n  /*\n  R1 and R2 are first set up in the standard way (see the note on R1\n  and R2), but then R1 is adjusted so that the region before it contains at\n  least 3 letters.\n  R1 is the region after the first non-vowel following a vowel, or is\n  the null region at the end of the word if there is no such non-vowel.\n  R2 is the region after the first non-vowel following a vowel in R1,\n  or is the null region at the end of the word if there is no such non-vowel.\n  */\n\n  let r1Index = word.search(/[aeiouyäöü][^aeiouyäöü]/)\n  let r1 = ''\n  if (r1Index !== -1) {\n    r1Index += 2\n    r1 = word.substring(r1Index)\n  }\n\n  let r2Index = -1\n  // let r2 = ''\n\n  if (r1Index !== -1) {\n    r2Index = r1.search(/[aeiouyäöü][^aeiouyäöü]/)\n    if (r2Index !== -1) {\n      r2Index += 2\n      // r2 = r1.substring(r2Index)\n      r2Index += r1Index\n    } else {\n      // r2 = ''\n    }\n  }\n\n  if (r1Index !== -1 && r1Index < 3) {\n    r1Index = 3\n    r1 = word.substring(r1Index)\n  }\n\n  /*\n  Define a valid s-ending as one of b, d, f, g, h, k, l, m, n, r or t.\n  Define a valid st-ending as the same list, excluding letter r.\n  */\n\n  /*\n  Do each of steps 1, 2 and 3.\n  */\n\n  /*\n  Step 1:\n  Search for the longest among the following suffixes,\n  (a) em ern er\n  (b) e en es\n  (c) s (preceded by a valid s-ending)\n  */\n  const a1Index = word.search(/(em|ern|er)$/g)\n  const b1Index = word.search(/(e|en|es)$/g)\n  let c1Index = word.search(/([bdfghklmnrt]s)$/g)\n  if (c1Index !== -1) {\n    c1Index++\n  }\n  let index1 = 10000\n  let optionUsed1 = ''\n  if (a1Index !== -1 && a1Index < index1) {\n    optionUsed1 = 'a'\n    index1 = a1Index\n  }\n  if (b1Index !== -1 && b1Index < index1) {\n    optionUsed1 = 'b'\n    index1 = b1Index\n  }\n  if (c1Index !== -1 && c1Index < index1) {\n    optionUsed1 = 'c'\n    index1 = c1Index\n  }\n\n  /*\n  and delete if in R1. (Of course the letter of the valid s-ending is\n  not necessarily in R1.) If an ending of group (b) is deleted, and the ending\n  is preceded by niss, delete the final s.\n  (For example, äckern -> äck, ackers -> acker, armes -> arm,\n  bedürfnissen -> bedürfnis)\n  */\n\n  if (index1 !== 10000 && r1Index !== -1) {\n    if (index1 >= r1Index) {\n      word = word.substring(0, index1)\n      if (optionUsed1 === 'b') {\n        if (word.search(/niss$/) !== -1) {\n          word = word.substring(0, word.length - 1)\n        }\n      }\n    }\n  }\n\n  /*\n  Step 2:\n  Search for the longest among the following suffixes,\n  (a) en er est\n  (b) st (preceded by a valid st-ending, itself preceded by at least 3\n  letters)\n  */\n\n  const a2Index = word.search(/(en|er|est)$/g)\n  let b2Index = word.search(/(.{3}[bdfghklmnt]st)$/g)\n  if (b2Index !== -1) {\n    b2Index += 4\n  }\n\n  let index2 = 10000\n  // const optionUsed2 = ''\n  if (a2Index !== -1 && a2Index < index2) {\n    // optionUsed2 = 'a'\n    index2 = a2Index\n  }\n  if (b2Index !== -1 && b2Index < index2) {\n    // optionUsed2 = 'b'\n    index2 = b2Index\n  }\n\n  /*\n  and delete if in R1.\n  (For example, derbsten -> derbst by step 1, and derbst -> derb by\n  step 2, since b is a valid st-ending, and is preceded by just 3 letters)\n  */\n\n  if (index2 !== 10000 && r1Index !== -1) {\n    if (index2 >= r1Index) {\n      word = word.substring(0, index2)\n    }\n  }\n\n  /*\n  Step 3: d-suffixes (*)\n  Search for the longest among the following suffixes, and perform the\n  action indicated.\n  end ung\n  delete if in R2\n  if preceded by ig, delete if in R2 and not preceded by e\n  ig ik isch\n  delete if in R2 and not preceded by e\n  lich heit\n  delete if in R2\n  if preceded by er or en, delete if in R1\n  keit\n  delete if in R2\n  if preceded by lich or ig, delete if in R2\n  */\n\n  const a3Index = word.search(/(end|ung)$/g)\n  let b3Index = word.search(/[^e](ig|ik|isch)$/g)\n  const c3Index = word.search(/(lich|heit)$/g)\n  const d3Index = word.search(/(keit)$/g)\n  if (b3Index !== -1) {\n    b3Index++\n  }\n\n  let index3 = 10000\n  let optionUsed3 = ''\n  if (a3Index !== -1 && a3Index < index3) {\n    optionUsed3 = 'a'\n    index3 = a3Index\n  }\n  if (b3Index !== -1 && b3Index < index3) {\n    optionUsed3 = 'b'\n    index3 = b3Index\n  }\n  if (c3Index !== -1 && c3Index < index3) {\n    optionUsed3 = 'c'\n    index3 = c3Index\n  }\n  if (d3Index !== -1 && d3Index < index3) {\n    optionUsed3 = 'd'\n    index3 = d3Index\n  }\n\n  if (index3 !== 10000 && r2Index !== -1) {\n    if (index3 >= r2Index) {\n      word = word.substring(0, index3)\n      let optionIndex = -1\n      // const optionSubsrt = ''\n      if (optionUsed3 === 'a') {\n        optionIndex = word.search(/[^e](ig)$/)\n        if (optionIndex !== -1) {\n          optionIndex++\n          if (optionIndex >= r2Index) {\n            word = word.substring(0, optionIndex)\n          }\n        }\n      } else if (optionUsed3 === 'c') {\n        optionIndex = word.search(/(er|en)$/)\n        if (optionIndex !== -1) {\n          if (optionIndex >= r1Index) {\n            word = word.substring(0, optionIndex)\n          }\n        }\n      } else if (optionUsed3 === 'd') {\n        optionIndex = word.search(/(lich|ig)$/)\n        if (optionIndex !== -1) {\n          if (optionIndex >= r2Index) {\n            word = word.substring(0, optionIndex)\n          }\n        }\n      }\n    }\n  }\n\n  /*\n  Finally,\n  turn U and Y back into lower case, and remove the umlaut accent from\n  a, o and u.\n  */\n  word = word.replace(/U/g, 'u')\n  word = word.replace(/Y/g, 'y')\n  word = word.replace(/ä/g, 'a')\n  word = word.replace(/ö/g, 'o')\n  word = word.replace(/ü/g, 'u')\n\n  return word\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}