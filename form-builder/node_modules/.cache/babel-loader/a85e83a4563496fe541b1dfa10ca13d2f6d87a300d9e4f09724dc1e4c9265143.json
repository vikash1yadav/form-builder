{"ast":null,"code":"/*\n  Lexicon class\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict';\n\nconst englishLexicon = require('../data/English/lexicon_from_posjs.json');\nconst dutchLexicon = require('../data/Dutch/brill_Lexicon.json');\nconst DEBUG = false;\n\n// Constructor creates a Lexicon for language\nfunction Lexicon(language, defaultCategory, defaultCategoryCapitalised) {\n  switch (language) {\n    case 'EN':\n      this.lexicon = englishLexicon;\n      break;\n    case 'DU':\n      this.lexicon = dutchLexicon;\n      break;\n    default:\n      this.lexicon = dutchLexicon;\n      break;\n  }\n  if (defaultCategory) {\n    this.defaultCategory = defaultCategory;\n    if (defaultCategoryCapitalised) {\n      this.defaultCategoryCapitalised = defaultCategoryCapitalised;\n    }\n  }\n}\n\n// Parses a lexicon in text format: word cat1 cat2 ... catn\nLexicon.prototype.parseLexicon = function (data) {\n  // Split into an array of non-empty lines\n  const arrayOfLines = data.match(/[^\\r\\n]+/g);\n  this.lexicon = {}; // Object.create(null);\n  const that = this;\n  arrayOfLines.forEach(function (line) {\n    // Split line by whitespace\n    const elements = line.trim().split(/\\s+/);\n    if (elements.length > 0) {\n      that.lexicon[elements[0]] = elements.slice(1);\n    }\n  });\n};\nLexicon.prototype.tagWordWithDefaults = function (word) {\n  if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n    // Capitalised\n    return this.defaultCategoryCapitalised;\n  } else {\n    // If not found assign default_category\n    return this.defaultCategory;\n  }\n};\n\n// Returns a list of categories for word\nLexicon.prototype.tagWord = function (word) {\n  let categories = this.lexicon[word];\n  DEBUG && console.log(categories);\n  if (!categories || typeof categories === 'function') {\n    categories = this.lexicon[word.toLowerCase()];\n  }\n  if (!categories || typeof categories === 'function') {\n    categories = [this.tagWordWithDefaults(word)];\n  }\n  return categories;\n};\n\n// Adds a word to the lexicon. NB simply replaces the entry\nLexicon.prototype.addWord = function (word, categories) {\n  this.lexicon[word] = categories;\n};\nLexicon.prototype.prettyPrint = function () {\n  let result = '';\n  const that = this;\n  Object.keys(this.lexicon).forEach(function (token) {\n    result += token + '\\t';\n    that.lexicon[token].forEach(function (cat) {\n      result += cat + '\\t';\n    });\n    result += '\\n';\n  });\n  return result;\n};\nLexicon.prototype.nrEntries = function () {\n  return Object.keys(this.lexicon).length;\n};\nLexicon.prototype.size = function () {\n  return this.nrEntries();\n};\nLexicon.prototype.setDefaultCategories = function (category, categoryCapitalised) {\n  this.defaultCategory = category;\n  if (categoryCapitalised) {\n    this.defaultCategoryCapitalised = categoryCapitalised;\n  }\n};\nmodule.exports = Lexicon;","map":{"version":3,"names":["englishLexicon","require","dutchLexicon","DEBUG","Lexicon","language","defaultCategory","defaultCategoryCapitalised","lexicon","prototype","parseLexicon","data","arrayOfLines","match","that","forEach","line","elements","trim","split","length","slice","tagWordWithDefaults","word","test","tagWord","categories","console","log","toLowerCase","addWord","prettyPrint","result","Object","keys","token","cat","nrEntries","size","setDefaultCategories","category","categoryCapitalised","module","exports"],"sources":["C:/Users/shail/OneDrive/Documents/GitHub/form-builder/form-builder/node_modules/natural/lib/natural/brill_pos_tagger/lib/Lexicon.js"],"sourcesContent":["/*\n  Lexicon class\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst englishLexicon = require('../data/English/lexicon_from_posjs.json')\nconst dutchLexicon = require('../data/Dutch/brill_Lexicon.json')\n\nconst DEBUG = false\n\n// Constructor creates a Lexicon for language\nfunction Lexicon (language, defaultCategory, defaultCategoryCapitalised) {\n  switch (language) {\n    case 'EN':\n      this.lexicon = englishLexicon\n      break\n    case 'DU':\n      this.lexicon = dutchLexicon\n      break\n    default:\n      this.lexicon = dutchLexicon\n      break\n  }\n  if (defaultCategory) {\n    this.defaultCategory = defaultCategory\n    if (defaultCategoryCapitalised) {\n      this.defaultCategoryCapitalised = defaultCategoryCapitalised\n    }\n  }\n}\n\n// Parses a lexicon in text format: word cat1 cat2 ... catn\nLexicon.prototype.parseLexicon = function (data) {\n  // Split into an array of non-empty lines\n  const arrayOfLines = data.match(/[^\\r\\n]+/g)\n  this.lexicon = {} // Object.create(null);\n  const that = this\n  arrayOfLines.forEach(function (line) {\n    // Split line by whitespace\n    const elements = line.trim().split(/\\s+/)\n    if (elements.length > 0) {\n      that.lexicon[elements[0]] = elements.slice(1)\n    }\n  })\n}\n\nLexicon.prototype.tagWordWithDefaults = function (word) {\n  if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n    // Capitalised\n    return this.defaultCategoryCapitalised\n  } else {\n    // If not found assign default_category\n    return this.defaultCategory\n  }\n}\n\n// Returns a list of categories for word\nLexicon.prototype.tagWord = function (word) {\n  let categories = this.lexicon[word]\n  DEBUG && console.log(categories)\n  if (!categories || (typeof categories === 'function')) {\n    categories = this.lexicon[word.toLowerCase()]\n  }\n  if (!categories || (typeof categories === 'function')) {\n    categories = [this.tagWordWithDefaults(word)]\n  }\n  return (categories)\n}\n\n// Adds a word to the lexicon. NB simply replaces the entry\nLexicon.prototype.addWord = function (word, categories) {\n  this.lexicon[word] = categories\n}\n\nLexicon.prototype.prettyPrint = function () {\n  let result = ''\n  const that = this\n  Object.keys(this.lexicon).forEach(function (token) {\n    result += token + '\\t'\n    that.lexicon[token].forEach(function (cat) {\n      result += cat + '\\t'\n    })\n    result += '\\n'\n  })\n  return result\n}\n\nLexicon.prototype.nrEntries = function () {\n  return Object.keys(this.lexicon).length\n}\n\nLexicon.prototype.size = function () {\n  return this.nrEntries()\n}\n\nLexicon.prototype.setDefaultCategories = function (category, categoryCapitalised) {\n  this.defaultCategory = category\n  if (categoryCapitalised) {\n    this.defaultCategoryCapitalised = categoryCapitalised\n  }\n}\n\nmodule.exports = Lexicon\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}