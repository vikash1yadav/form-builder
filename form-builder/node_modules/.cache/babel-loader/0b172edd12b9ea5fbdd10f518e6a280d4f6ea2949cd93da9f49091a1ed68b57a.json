{"ast":null,"code":"/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict';\n\nconst Predicate = require('./Predicate');\n\n// logger.setLevel('INFO');\n\nconst categoryWildCard = '*';\nfunction TransformationRule(c1, c2, predicate, parameter1, parameter2) {\n  this.literal = [c1, c2, predicate, parameter1, parameter2];\n  this.predicate = new Predicate(predicate, parameter1, parameter2);\n  this.oldCategory = c1;\n  this.newCategory = c2;\n  // These members are for the learning algorithm\n  this.neutral = 0;\n  this.negative = 0;\n  this.positive = 0;\n  this.hasBeenSelectedAsHighRuleBefore = false;\n}\nTransformationRule.prototype.key = function () {\n  return this.literal.toString();\n};\nTransformationRule.prototype.apply = function (sentence, position) {\n  if (sentence.taggedWords[position].tag === this.oldCategory || this.oldCategory === categoryWildCard) {\n    if (this.predicate.evaluate(sentence, position)) {\n      sentence.taggedWords[position].tag = this.newCategory;\n    }\n  }\n};\n\n//\n// Methods for processing sentences from a corpus that consist of an array of tokens\n//\n\n// Returns true if the rule applies at site. As a side effect it assigns the new\n// category to newTag\nTransformationRule.prototype.isApplicableAt = function (sentence, taggedSentence, i) {\n  const applies = taggedSentence.taggedWords[i].tag === this.oldCategory && this.predicate.evaluate(taggedSentence, i);\n\n  // Set newTag to let the trainer know what the new tag would become\n  if (applies) {\n    sentence.taggedWords[i].newTag = this.newCategory;\n  }\n  return applies;\n};\nTransformationRule.prototype.prettyPrint = function () {\n  let result = '';\n  // Old category and new category\n  result += this.oldCategory + ' ' + this.newCategory;\n  // Predicate name\n  result += ' ' + this.predicate.name;\n  // Parameter 1 and 2\n  if (this.predicate.parameter1) {\n    result += ' ' + this.predicate.parameter1;\n    if (this.predicate.parameter2) {\n      result += ' ' + this.predicate.parameter2;\n    }\n  }\n  return result;\n};\n\n// Applies the rule the given location (if it applies)\nTransformationRule.prototype.applyAt = function (sentence, i) {\n  const taggedSentence = sentence.clone();\n  this.apply(sentence, i);\n  // Assign the new tag to the corpus site\n  sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag;\n};\n\n// Calculate the net score of this rule\nTransformationRule.prototype.score = function () {\n  return this.positive - this.negative;\n};\nmodule.exports = TransformationRule;","map":{"version":3,"names":["Predicate","require","categoryWildCard","TransformationRule","c1","c2","predicate","parameter1","parameter2","literal","oldCategory","newCategory","neutral","negative","positive","hasBeenSelectedAsHighRuleBefore","prototype","key","toString","apply","sentence","position","taggedWords","tag","evaluate","isApplicableAt","taggedSentence","i","applies","newTag","prettyPrint","result","name","applyAt","clone","testTag","score","module","exports"],"sources":["C:/Users/shail/OneDrive/Documents/GitHub/form-builder/form-builder/node_modules/natural/lib/natural/brill_pos_tagger/lib/TransformationRule.js"],"sourcesContent":["/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst Predicate = require('./Predicate')\n\n// logger.setLevel('INFO');\n\nconst categoryWildCard = '*'\n\nfunction TransformationRule (c1, c2, predicate, parameter1, parameter2) {\n  this.literal = [c1, c2, predicate, parameter1, parameter2]\n  this.predicate = new Predicate(predicate, parameter1, parameter2)\n  this.oldCategory = c1\n  this.newCategory = c2\n  // These members are for the learning algorithm\n  this.neutral = 0\n  this.negative = 0\n  this.positive = 0\n  this.hasBeenSelectedAsHighRuleBefore = false\n}\n\nTransformationRule.prototype.key = function () {\n  return (this.literal.toString())\n}\n\nTransformationRule.prototype.apply = function (sentence, position) {\n  if ((sentence.taggedWords[position].tag === this.oldCategory) ||\n      (this.oldCategory === categoryWildCard)) {\n    if (this.predicate.evaluate(sentence, position)) {\n      sentence.taggedWords[position].tag = this.newCategory\n    }\n  }\n}\n\n//\n// Methods for processing sentences from a corpus that consist of an array of tokens\n//\n\n// Returns true if the rule applies at site. As a side effect it assigns the new\n// category to newTag\nTransformationRule.prototype.isApplicableAt = function (sentence, taggedSentence, i) {\n  const applies = (taggedSentence.taggedWords[i].tag === this.oldCategory) &&\n    this.predicate.evaluate(taggedSentence, i)\n\n  // Set newTag to let the trainer know what the new tag would become\n  if (applies) {\n    sentence.taggedWords[i].newTag = this.newCategory\n  }\n  return (applies)\n}\n\nTransformationRule.prototype.prettyPrint = function () {\n  let result = ''\n  // Old category and new category\n  result += this.oldCategory + ' ' + this.newCategory\n  // Predicate name\n  result += ' ' + this.predicate.name\n  // Parameter 1 and 2\n  if (this.predicate.parameter1) {\n    result += ' ' + this.predicate.parameter1\n    if (this.predicate.parameter2) {\n      result += ' ' + this.predicate.parameter2\n    }\n  }\n  return result\n}\n\n// Applies the rule the given location (if it applies)\nTransformationRule.prototype.applyAt = function (sentence, i) {\n  const taggedSentence = sentence.clone()\n\n  this.apply(sentence, i)\n  // Assign the new tag to the corpus site\n  sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag\n}\n\n// Calculate the net score of this rule\nTransformationRule.prototype.score = function () {\n  return (this.positive - this.negative)\n}\n\nmodule.exports = TransformationRule\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}