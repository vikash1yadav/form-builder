{"ast":null,"code":"/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n\n'use strict';\n\nconst TransformationRule = require('./TransformationRule');\nconst RuleSet = require('./RuleSet');\nconst Sentence = require('./Sentence');\n\n// Training continues as long as there are rules with a positive score\n// that have not been selected before\nconst minScore = 0;\n\n// After training rules with a score below scoreThreshold are pruned\nfunction BrillPOSTrainer(ruleScoreThreshold) {\n  if (ruleScoreThreshold) {\n    this.ruleScoreThreshold = ruleScoreThreshold;\n  } else {\n    this.ruleScoreThreshold = 1;\n  }\n}\n\n// Return the highest scoring rule from the rule set\nBrillPOSTrainer.prototype.selectHighRule = function () {\n  let highestRule = null;\n\n  // Walk through the map and find the rule with highest score\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (highestRule === null) {\n      if (!rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    } else {\n      if (rule.score() > highestRule.score() && !rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    }\n  });\n  if (highestRule !== null) {\n    highestRule.hasBeenSelectedAsHighRuleBefore = true;\n  }\n  // Return the rule with the highest score\n  return highestRule;\n};\nBrillPOSTrainer.prototype.mapRuleToSite = function (rule, i, j) {\n  if (!this.mapRuleToSites[rule.key()]) {\n    this.mapRuleToSites[rule.key()] = {};\n  }\n  if (!this.mapRuleToSites[rule.key()][i]) {\n    this.mapRuleToSites[rule.key()][i] = {};\n  }\n  this.mapRuleToSites[rule.key()][i][j] = true;\n};\nBrillPOSTrainer.prototype.mapSiteToRule = function (i, j, rule) {\n  if (!this.mapSiteToRules[i]) {\n    this.mapSiteToRules[i] = {};\n  }\n  if (!this.mapSiteToRules[i][j]) {\n    this.mapSiteToRules[i][j] = {};\n  }\n  this.mapSiteToRules[i][j][rule.key()] = rule;\n};\nBrillPOSTrainer.prototype.associateSiteWithRule = function (i, j, rule) {\n  this.mapRuleToSite(rule, i, j);\n  this.mapSiteToRule(i, j, rule);\n};\nBrillPOSTrainer.prototype.siteIsAssociatedWithRule = function (i, j, rule) {\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// Returns an array of all sites associated with rule\nBrillPOSTrainer.prototype.getSites = function (rule) {\n  const that = this;\n  const result = [];\n  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n      // Unary plus the convert hash keys i and j to integer\n      result.push([+i, +j]);\n    });\n  });\n  // logger.debug(\"BrillPOSTrainer.prototype.getSites: sites \" + JSON.stringify(result));\n  return result;\n};\n\n// Returns an array of all rules associated with the site\nBrillPOSTrainer.prototype.getRules = function (i, j) {\n  let result = [];\n  const that = this;\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n        return that.mapSiteToRules[i][j][key];\n      });\n    }\n  }\n  return result;\n};\nBrillPOSTrainer.prototype.disconnectSiteFromRule = function (i, j, rule) {\n  // mapRuleToSites\n  if (this.mapRuleToSites[rule.key()]) {\n    if (this.mapRuleToSites[rule.key()][i]) {\n      if (this.mapRuleToSites[rule.key()][i][j]) {\n        delete this.mapRuleToSites[rule.key()][i][j];\n      }\n    }\n  }\n\n  // mapSiteToRules\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        delete this.mapSiteToRules[i][j][rule.key()];\n      }\n    }\n  }\n};\n\n// Adjusts the score of the rule at position i, j of the corpus\nBrillPOSTrainer.prototype.scoreRule = function (rule, i, j) {\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: entry\");\n  const token = this.corpus.sentences[i].taggedWords[j];\n  const rightTag = token.tag;\n  const oldTag = token.testTag;\n  const newTag = token.newTag;\n  if (rightTag !== oldTag) {\n    // Old tag is wrong\n    if (newTag === rightTag) {\n      // New tag is right\n      rule.positive++;\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false;\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n    } else {\n      // New tag is wrong as well --> neutral\n      rule.neutral++;\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    }\n  } else {\n    // Old tag is right\n    if (newTag === rightTag) {\n      // New tag is right --> neutral\n      rule.neutral++;\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    } else {\n      // New tag is false\n      rule.negative++;\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false;\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n    }\n  }\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: exit\");\n};\n\n// Generate positive rules for this given site using templates\nBrillPOSTrainer.prototype.generatePositiveRules = function (i, j) {\n  const sentence = this.corpus.sentences[i];\n  const token = sentence.taggedWords[j];\n  // A positive rule should trigger on the currently assigned testTag\n  const oldTag = token.testTag;\n  // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n  // It should assign the right tag as given by the corpus\n  const newTag = token.tag;\n  // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n  const newRules = new RuleSet();\n  // Exit if testTag already is the right tag --> will not result in positive rules\n  if (oldTag === newTag) {\n    return newRules;\n  }\n  this.templates.forEach(function (template) {\n    if (template.windowFitsSite(sentence, j)) {\n      if (template.meta.nrParameters === 1) {\n        template.meta.parameter1Values(sentence, j).forEach(function (value) {\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value));\n        });\n      } else {\n        if (template.meta.nrParameters === 2) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n            template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2));\n            });\n          });\n        } else {\n          // 0 paramaters\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName));\n        }\n      }\n    }\n  });\n  return newRules;\n};\n\n// Finds all rules that are applicable at some site\nBrillPOSTrainer.prototype.scanForPositiveRules = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: entry\");\n  const that = this;\n  this.corpus.sentences.forEach(function (sentence, i) {\n    sentence.taggedWords.forEach(function (token, j) {\n      // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: sentence no \" + i);\n      const newRules = that.generatePositiveRules(i, j);\n      newRules.getRules().forEach(function (rule) {\n        that.positiveRules.addRule(rule);\n        // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n      });\n    });\n  });\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n};\n\n// Find all sites where the rules can be applied, register these sites and\n// update the scores\nBrillPOSTrainer.prototype.scanForSites = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: entry\");\n  const that = this;\n\n  // Scan the corpus\n  this.corpus.sentences.forEach(function (sentence, i) {\n    if (i % 100 === 0) {\n      // logger.info(\"BrillPOSTrainer.prototype.scanForSites: sentence \" + i);\n    }\n    const taggedSentence = new Sentence();\n    sentence.taggedWords.forEach(function (wordObject) {\n      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag);\n    });\n    sentence.taggedWords.forEach(function (token, j) {\n      that.positiveRules.getRules().forEach(function (rule) {\n        if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n          that.associateSiteWithRule(i, j, rule);\n          that.scoreRule(rule, i, j);\n          // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n        }\n      });\n    });\n  });\n\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: exit\");\n};\n\n// Returns a list of sites that may have been touched by a changing tag\nBrillPOSTrainer.prototype.neighbourhood = function (i, j) {\n  const sentenceLength = this.corpus.sentences[i].length;\n  const list = [];\n  if (this.index > 2) {\n    list.push([i, j - 3]);\n  }\n  if (this.index > 1) {\n    list.push([i, j - 2]);\n  }\n  if (this.index > 0) {\n    list.push([i, j - 1]);\n  }\n  if (this.index < sentenceLength - 1) {\n    list.push([i, j + 1]);\n  }\n  if (this.index < sentenceLength - 2) {\n    list.push([i, j + 2]);\n  }\n  if (this.index > sentenceLength - 3) {\n    list.push([i, j + 3]);\n  }\n  return list;\n};\n\n// corpus: an array of token arrays\n// templates: an array of rule templates\n// lexicon: lexicon that provides method tagWord(word)\nBrillPOSTrainer.prototype.train = function (corpus, templates, lexicon) {\n  this.corpus = corpus;\n  this.templates = templates;\n  this.positiveRules = new RuleSet();\n  this.mapRuleToSites = {};\n  this.mapSiteToRules = {};\n\n  // logger.debug(\"BrillPOSTrainer.prototype.train: entry\");\n  this.corpus.tag(lexicon);\n  this.scanForPositiveRules();\n  // logger.info(\"BrillPOSTrainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n  this.scanForSites();\n  let highRule = this.selectHighRule();\n  let iterationNumber = 0;\n  const that = this;\n  while (highRule !== null && highRule.score() > minScore) {\n    if (iterationNumber % 5 === 0) {\n      // logger.info(\"BrillPOSTrainer.prototype.train: training iteration: \" + iterationNumber);\n    }\n    // logger.debug(\"BrillPOSTrainer.prototype.train: highRule selected: \" + highRule.key());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: score of highRule: \" + highRule.score());\n\n    // Apply the high rule to each change site on its site list\n    this.getSites(highRule).forEach(function (site) {\n      // logger.debug(\"BrillPOSTrainer.prototype.train: apply highRule to: \" + site);\n      // logger.debug(\"BrillPOSTrainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n      highRule.applyAt(that.corpus.sentences[site[0]], site[1]);\n    });\n    const unseenRules = new RuleSet();\n    this.getSites(highRule).forEach(function (site) {\n      that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n        // Generate positive rules for testSite\n        const newRules = that.generatePositiveRules(testSite[0], testSite[1]);\n\n        // Disconnect test site from its rules\n        // because highrule has been applied\n        that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n          if (!newRules.hasRule(rule)) {\n            that.disconnectSiteFromRule(testSite[0], testSite[1], rule);\n          }\n        });\n\n        // Connect new rules not already connected to the test site\n        newRules.getRules().forEach(function (rule) {\n          if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n            if (that.positiveRules.hasRule(rule)) {\n              that.associateSiteWithRule(testSite[0], testSite[1], rule);\n            } else {\n              unseenRules.addRule(rule);\n            }\n          }\n        });\n\n        // Process unseen rules\n        if (unseenRules.nrRules() > 0) {\n          unseenRules.getRules().forEach(function (rule) {\n            that.positiveRules.addRule(rule);\n          });\n          that.corpus.sentences.forEach(function (sentence, i) {\n            const taggedSentence = sentence.map(function (token) {\n              return [token.token, token.testTag];\n            });\n            sentence.forEach(function (token, j) {\n              unseenRules.getRules().forEach(function (rule) {\n                if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                  that.associateSiteWithRule(i, j, rule);\n                  that.scoreRule(rule, i, j);\n                }\n              });\n            });\n          });\n        }\n      });\n    });\n\n    // Select next highest scoring rule\n    highRule = this.selectHighRule();\n    iterationNumber++;\n  }\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of iterations: \" + iterationNumber);\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n\n  // Remove rules having a non-positive score\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (rule.score() < that.ruleScoreThreshold) {\n      that.positiveRules.removeRule(rule);\n    }\n  });\n\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n  // logger.debug(\"BrillPOSTrainer.prototype.train: exit\");\n  return this.positiveRules;\n};\nBrillPOSTrainer.prototype.printRulesWithScores = function () {\n  let result = '';\n  function compareRules(a, b) {\n    if (a.score() > b.score()) {\n      return -1;\n    } else {\n      if (a.score() < b.score()) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }\n  const rules = this.positiveRules.getRules();\n  const sortedRules = rules.sort(compareRules);\n  sortedRules.forEach(function (rule) {\n    // if (rule.score() > 0) {\n    result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + '\\n';\n    // }\n  });\n\n  return result;\n};\nmodule.exports = BrillPOSTrainer;","map":{"version":3,"names":["TransformationRule","require","RuleSet","Sentence","minScore","BrillPOSTrainer","ruleScoreThreshold","prototype","selectHighRule","highestRule","positiveRules","getRules","forEach","rule","hasBeenSelectedAsHighRuleBefore","score","mapRuleToSite","i","j","mapRuleToSites","key","mapSiteToRule","mapSiteToRules","associateSiteWithRule","siteIsAssociatedWithRule","getSites","that","result","Object","keys","push","map","disconnectSiteFromRule","scoreRule","token","corpus","sentences","taggedWords","rightTag","tag","oldTag","testTag","newTag","positive","neutral","negative","generatePositiveRules","sentence","newRules","templates","template","windowFitsSite","meta","nrParameters","parameter1Values","value","addRule","predicateName","value1","parameter2Values","value2","scanForPositiveRules","scanForSites","taggedSentence","wordObject","addTaggedWord","isApplicableAt","neighbourhood","sentenceLength","length","list","index","train","lexicon","highRule","iterationNumber","site","applyAt","unseenRules","testSite","hasRule","nrRules","removeRule","printRulesWithScores","compareRules","a","b","rules","sortedRules","sort","prettyPrint","module","exports"],"sources":["C:/Users/shail/OneDrive/Documents/GitHub/form-builder/form-builder/node_modules/natural/lib/natural/brill_pos_tagger/lib/Brill_POS_Trainer.js"],"sourcesContent":["/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n\n'use strict'\n\nconst TransformationRule = require('./TransformationRule')\nconst RuleSet = require('./RuleSet')\nconst Sentence = require('./Sentence')\n\n// Training continues as long as there are rules with a positive score\n// that have not been selected before\nconst minScore = 0\n\n// After training rules with a score below scoreThreshold are pruned\nfunction BrillPOSTrainer (ruleScoreThreshold) {\n  if (ruleScoreThreshold) {\n    this.ruleScoreThreshold = ruleScoreThreshold\n  } else {\n    this.ruleScoreThreshold = 1\n  }\n}\n\n// Return the highest scoring rule from the rule set\nBrillPOSTrainer.prototype.selectHighRule = function () {\n  let highestRule = null\n\n  // Walk through the map and find the rule with highest score\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (highestRule === null) {\n      if (!rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule\n      }\n    } else {\n      if ((rule.score() > highestRule.score()) &&\n        !rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule\n      }\n    }\n  })\n\n  if (highestRule !== null) {\n    highestRule.hasBeenSelectedAsHighRuleBefore = true\n  }\n  // Return the rule with the highest score\n  return highestRule\n}\n\nBrillPOSTrainer.prototype.mapRuleToSite = function (rule, i, j) {\n  if (!this.mapRuleToSites[rule.key()]) {\n    this.mapRuleToSites[rule.key()] = {}\n  }\n  if (!this.mapRuleToSites[rule.key()][i]) {\n    this.mapRuleToSites[rule.key()][i] = {}\n  }\n  this.mapRuleToSites[rule.key()][i][j] = true\n}\n\nBrillPOSTrainer.prototype.mapSiteToRule = function (i, j, rule) {\n  if (!this.mapSiteToRules[i]) {\n    this.mapSiteToRules[i] = {}\n  }\n  if (!this.mapSiteToRules[i][j]) {\n    this.mapSiteToRules[i][j] = {}\n  }\n  this.mapSiteToRules[i][j][rule.key()] = rule\n}\n\nBrillPOSTrainer.prototype.associateSiteWithRule = function (i, j, rule) {\n  this.mapRuleToSite(rule, i, j)\n  this.mapSiteToRule(i, j, rule)\n}\n\nBrillPOSTrainer.prototype.siteIsAssociatedWithRule = function (i, j, rule) {\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n// Returns an array of all sites associated with rule\nBrillPOSTrainer.prototype.getSites = function (rule) {\n  const that = this\n  const result = []\n  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n      // Unary plus the convert hash keys i and j to integer\n      result.push([+i, +j])\n    })\n  })\n  // logger.debug(\"BrillPOSTrainer.prototype.getSites: sites \" + JSON.stringify(result));\n  return (result)\n}\n\n// Returns an array of all rules associated with the site\nBrillPOSTrainer.prototype.getRules = function (i, j) {\n  let result = []\n  const that = this\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n        return that.mapSiteToRules[i][j][key]\n      })\n    }\n  }\n  return result\n}\n\nBrillPOSTrainer.prototype.disconnectSiteFromRule = function (i, j, rule) {\n  // mapRuleToSites\n  if (this.mapRuleToSites[rule.key()]) {\n    if (this.mapRuleToSites[rule.key()][i]) {\n      if (this.mapRuleToSites[rule.key()][i][j]) {\n        delete this.mapRuleToSites[rule.key()][i][j]\n      }\n    }\n  }\n\n  // mapSiteToRules\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        delete this.mapSiteToRules[i][j][rule.key()]\n      }\n    }\n  }\n}\n\n// Adjusts the score of the rule at position i, j of the corpus\nBrillPOSTrainer.prototype.scoreRule = function (rule, i, j) {\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: entry\");\n  const token = this.corpus.sentences[i].taggedWords[j]\n  const rightTag = token.tag\n  const oldTag = token.testTag\n  const newTag = token.newTag\n  if (rightTag !== oldTag) {\n    // Old tag is wrong\n    if (newTag === rightTag) {\n      // New tag is right\n      rule.positive++\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n    } else {\n      // New tag is wrong as well --> neutral\n      rule.neutral++\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    }\n  } else {\n    // Old tag is right\n    if (newTag === rightTag) {\n      // New tag is right --> neutral\n      rule.neutral++\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    } else {\n      // New tag is false\n      rule.negative++\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n    }\n  }\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: exit\");\n}\n\n// Generate positive rules for this given site using templates\nBrillPOSTrainer.prototype.generatePositiveRules = function (i, j) {\n  const sentence = this.corpus.sentences[i]\n  const token = sentence.taggedWords[j]\n  // A positive rule should trigger on the currently assigned testTag\n  const oldTag = token.testTag\n  // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n  // It should assign the right tag as given by the corpus\n  const newTag = token.tag\n  // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n  const newRules = new RuleSet()\n  // Exit if testTag already is the right tag --> will not result in positive rules\n  if (oldTag === newTag) {\n    return newRules\n  }\n\n  this.templates.forEach(function (template) {\n    if (template.windowFitsSite(sentence, j)) {\n      if (template.meta.nrParameters === 1) {\n        template.meta.parameter1Values(sentence, j).forEach(function (value) {\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value))\n        })\n      } else {\n        if (template.meta.nrParameters === 2) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n            template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2))\n            })\n          })\n        } else {\n          // 0 paramaters\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName))\n        }\n      }\n    }\n  })\n  return newRules\n}\n\n// Finds all rules that are applicable at some site\nBrillPOSTrainer.prototype.scanForPositiveRules = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: entry\");\n  const that = this\n  this.corpus.sentences.forEach(function (sentence, i) {\n    sentence.taggedWords.forEach(function (token, j) {\n      // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: sentence no \" + i);\n      const newRules = that.generatePositiveRules(i, j)\n      newRules.getRules().forEach(function (rule) {\n        that.positiveRules.addRule(rule)\n        // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n      })\n    })\n  })\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n}\n\n// Find all sites where the rules can be applied, register these sites and\n// update the scores\nBrillPOSTrainer.prototype.scanForSites = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: entry\");\n  const that = this\n\n  // Scan the corpus\n  this.corpus.sentences.forEach(function (sentence, i) {\n    if (i % 100 === 0) {\n      // logger.info(\"BrillPOSTrainer.prototype.scanForSites: sentence \" + i);\n    }\n\n    const taggedSentence = new Sentence()\n    sentence.taggedWords.forEach(function (wordObject) {\n      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag)\n    })\n\n    sentence.taggedWords.forEach(function (token, j) {\n      that.positiveRules.getRules().forEach(function (rule) {\n        if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n          that.associateSiteWithRule(i, j, rule)\n          that.scoreRule(rule, i, j)\n          // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n        }\n      })\n    })\n  })\n\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: exit\");\n}\n\n// Returns a list of sites that may have been touched by a changing tag\nBrillPOSTrainer.prototype.neighbourhood = function (i, j) {\n  const sentenceLength = this.corpus.sentences[i].length\n  const list = []\n\n  if (this.index > 2) {\n    list.push([i, j - 3])\n  }\n  if (this.index > 1) {\n    list.push([i, j - 2])\n  }\n  if (this.index > 0) {\n    list.push([i, j - 1])\n  }\n  if (this.index < sentenceLength - 1) {\n    list.push([i, j + 1])\n  }\n  if (this.index < sentenceLength - 2) {\n    list.push([i, j + 2])\n  }\n  if (this.index > sentenceLength - 3) {\n    list.push([i, j + 3])\n  }\n  return list\n}\n\n// corpus: an array of token arrays\n// templates: an array of rule templates\n// lexicon: lexicon that provides method tagWord(word)\nBrillPOSTrainer.prototype.train = function (corpus, templates, lexicon) {\n  this.corpus = corpus\n  this.templates = templates\n  this.positiveRules = new RuleSet()\n  this.mapRuleToSites = {}\n  this.mapSiteToRules = {}\n\n  // logger.debug(\"BrillPOSTrainer.prototype.train: entry\");\n  this.corpus.tag(lexicon)\n  this.scanForPositiveRules()\n  // logger.info(\"BrillPOSTrainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n  this.scanForSites()\n\n  let highRule = this.selectHighRule()\n  let iterationNumber = 0\n  const that = this\n  while ((highRule !== null) && (highRule.score() > minScore)) {\n    if ((iterationNumber % 5) === 0) {\n      // logger.info(\"BrillPOSTrainer.prototype.train: training iteration: \" + iterationNumber);\n    }\n    // logger.debug(\"BrillPOSTrainer.prototype.train: highRule selected: \" + highRule.key());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: score of highRule: \" + highRule.score());\n\n    // Apply the high rule to each change site on its site list\n    this.getSites(highRule).forEach(function (site) {\n      // logger.debug(\"BrillPOSTrainer.prototype.train: apply highRule to: \" + site);\n      // logger.debug(\"BrillPOSTrainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n      highRule.applyAt(that.corpus.sentences[site[0]], site[1])\n    })\n\n    const unseenRules = new RuleSet()\n    this.getSites(highRule).forEach(function (site) {\n      that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n        // Generate positive rules for testSite\n        const newRules = that.generatePositiveRules(testSite[0], testSite[1])\n\n        // Disconnect test site from its rules\n        // because highrule has been applied\n        that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n          if (!newRules.hasRule(rule)) {\n            that.disconnectSiteFromRule(testSite[0], testSite[1], rule)\n          }\n        })\n\n        // Connect new rules not already connected to the test site\n        newRules.getRules().forEach(function (rule) {\n          if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n            if (that.positiveRules.hasRule(rule)) {\n              that.associateSiteWithRule(testSite[0], testSite[1], rule)\n            } else {\n              unseenRules.addRule(rule)\n            }\n          }\n        })\n\n        // Process unseen rules\n        if (unseenRules.nrRules() > 0) {\n          unseenRules.getRules().forEach(function (rule) {\n            that.positiveRules.addRule(rule)\n          })\n          that.corpus.sentences.forEach(function (sentence, i) {\n            const taggedSentence = sentence.map(function (token) {\n              return [token.token, token.testTag]\n            })\n            sentence.forEach(function (token, j) {\n              unseenRules.getRules().forEach(function (rule) {\n                if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                  that.associateSiteWithRule(i, j, rule)\n                  that.scoreRule(rule, i, j)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n\n    // Select next highest scoring rule\n    highRule = this.selectHighRule()\n    iterationNumber++\n  }\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of iterations: \" + iterationNumber);\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n\n  // Remove rules having a non-positive score\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (rule.score() < that.ruleScoreThreshold) {\n      that.positiveRules.removeRule(rule)\n    }\n  })\n\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n  // logger.debug(\"BrillPOSTrainer.prototype.train: exit\");\n  return this.positiveRules\n}\n\nBrillPOSTrainer.prototype.printRulesWithScores = function () {\n  let result = ''\n\n  function compareRules (a, b) {\n    if (a.score() > b.score()) {\n      return -1\n    } else {\n      if (a.score() < b.score()) {\n        return 1\n      } else {\n        return 0\n      }\n    }\n  }\n\n  const rules = this.positiveRules.getRules()\n  const sortedRules = rules.sort(compareRules)\n\n  sortedRules.forEach(function (rule) {\n    // if (rule.score() > 0) {\n    result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + '\\n'\n    // }\n  })\n  return result\n}\n\nmodule.exports = BrillPOSTrainer\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}